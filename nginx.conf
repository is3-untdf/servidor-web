server {

    listen 80;

    # Usa el DNS interno de Docker para resolver nombres cuando se necesiten, no solo al inicio.
    resolver 127.0.0.11 valid=10s;

    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ =404;
    }

    # para tener acceso a los js, css y demás archivos que use el proyecto es necesaria esta redirección
    location = /gpe2024 {
        return 301 /gpe2024/;
    }

    location /gpe2024/ {

        # Usamos una variable para que no se reinicie el servidor web si el contenedor de gpe no está levantado.
        # Esto fuerza a nginx a usar el "resolver" en tiempo de ejecución (cuando llega una petición).
        set $gpe_front "http://gpe_front:80";
        proxy_pass $gpe_front;

        #proxy_pass http://gpe_front:80/gpe2024/;

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_ssl_session_reuse off;
        proxy_set_header Host $http_host;
        proxy_cache_bypass $http_upgrade;
        proxy_redirect off;
    }

    location = /mapa2025 {
        return 301 /mapa2025/;
    }

    location /mapa2025/ {

        # Usamos una variabe para que no se reinicie el servidor web si e contenedor de mapa no está levantado.
        # Esto fuerza a nginx a usar el "resolver" en tiempo de ejecución (cuando llega una petición).      
        set $mapa_front "http://mapa_front:80";
        proxy_pass $mapa_front;

        #proxy_pass http://mapa_front:80/mapa2025/;

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_ssl_session_reuse off;
        proxy_set_header Host $http_host;
        proxy_cache_bypass $http_upgrade;
        proxy_redirect off;
    }
}
